import { Token } from './tokens.js';
declare type ValueOf<T> = T[keyof T];
declare type SCPBoolean = 0 | 1;
declare type SCPImage = {
    altText?: string;
    fileId?: number;
    type: 'image';
    url: string;
    width?: number;
    height?: number;
};
declare const SCPContentStates: {
    readonly DRAFT: "DRAFT";
    readonly PUBLISHED: "PUBLISHED";
};
declare type SCPContentState = ValueOf<typeof SCPContentStates>;
interface SCPContentTypeBase {
    hs_id: number;
    hs_child_table_id: number;
    hs_domain: string;
    hs_updated_at: number;
    hs_slug: string;
    hs_analytics_page_id: string;
    hs_path: string;
    hs_language: string;
    hs_state: SCPContentState;
    hs_group_id: number;
    hs_created_by_user_id: number;
    hs_created_at: number;
    hs_is_edited: SCPBoolean;
    hs_deleted_at: number;
    hs_access_rule_ids: number[];
    hs_updated_by_user_id: number;
    hs_name: string;
    hs_published_at: number;
}
declare type SCPFile = {
    id: number;
    type: 'file';
    url: string;
};
declare type AudioSource = {
    name: 'hs_user_upload' | 'hs_text_to_audio';
};
export interface PodcastEpisode extends SCPContentTypeBase {
    hs_absolute_url: string;
    hs_audio_file: SCPFile;
    hs_audio_source: AudioSource;
    hs_description: string;
    hs_author?: string[];
    hs_link?: string;
    hs_image: SCPImage;
    hs_explicit?: SCPBoolean;
    hs_transcript?: string;
    hs_transcript_file?: SCPFile;
    hs_initial_published_at: number;
    hs_duration_millis?: number;
    hs_is_ai_generated?: SCPBoolean;
}
export declare function unstable_usePodcastEpisodes(resolvableIds: Token): PodcastEpisode[];
export {};
