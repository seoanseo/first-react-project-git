import { renderToPipeableStream } from "react-dom/server";
import stream from "stream";
import { jsx } from "react/jsx-runtime";
function createSuspendingResourceFromPromiseFactory(promiseFactory) {
  let status = "pending";
  let result;
  let error;
  let suspenderPromise;
  return {
    read() {
      if (!suspenderPromise) {
        suspenderPromise = promiseFactory().then(
          (resolvedValue) => {
            status = "success";
            result = resolvedValue;
          },
          (e) => {
            status = "error";
            error = e;
          }
        );
      }
      if (status === "pending") {
        throw suspenderPromise;
      } else if (status === "success") {
        return result;
      }
      throw error;
    }
  };
}
var promiseForNewWritableStream = () => {
  const chunks = [];
  const writableStream = new stream.Writable();
  writableStream._write = (chunk, encoding, done) => {
    chunks.push(Buffer.from(chunk));
    done();
  };
  const streamDonePromise = new Promise((resolve, reject) => {
    writableStream.on("error", (error) => {
      reject(error);
    });
    writableStream._final = (done) => {
      resolve(Buffer.concat(chunks).toString("utf8"));
      done();
    };
  });
  return { streamDonePromise, writableStream };
};
var renderStreamToPromise = (reactElements, options) => {
  const { streamDonePromise, writableStream } = promiseForNewWritableStream();
  const {
    pipe
    /* abort */
  } = renderToPipeableStream(reactElements, {
    ...options || {},
    onAllReady() {
      pipe(writableStream);
      if (options == null ? void 0 : options.onAllReady) {
        options.onAllReady();
      }
    },
    onError(error) {
      if (options == null ? void 0 : options.onError) {
        options.onError(error);
      }
    }
  });
  return streamDonePromise;
};
var renderResourceByID = /* @__PURE__ */ new WeakMap();
function createPerRenderTreeLoadResource(renderID, innerTree, renderOptions) {
  let resource = renderResourceByID.get(renderID);
  if (resource) {
    return resource;
  }
  resource = createSuspendingResourceFromPromiseFactory(
    () => renderStreamToPromise(innerTree, renderOptions)
  );
  renderResourceByID.set(renderID, resource);
  return resource;
}
function RenderTreeSeparately({
  innerTree,
  uniqueRenderID,
  renderOptions,
  WrapperElement,
  wrapperID,
  wrapperStyle,
  wrapperClassName
}) {
  const html = createPerRenderTreeLoadResource(
    uniqueRenderID,
    innerTree,
    renderOptions
  ).read();
  return /* @__PURE__ */ jsx(
    WrapperElement,
    {
      "data-hs-island": true,
      id: wrapperID,
      style: wrapperStyle,
      className: wrapperClassName,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
}
export {
  RenderTreeSeparately,
  createPerRenderTreeLoadResource
};
