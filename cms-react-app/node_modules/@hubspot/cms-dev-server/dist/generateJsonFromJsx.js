#!/usr/bin/env node

// src/generateJsonFromJsx.ts
import path3 from "path";
import fs from "fs/promises";
import { normalizePath as normalizePath2 } from "vite";

// src/createViteDevServer.ts
import { createServer as createViteServer } from "vite";
import { default as react } from "@vitejs/plugin-react";

// ../cms-js-internal/dist/types-CnX5J5m1.js
import path from "path";
var viteRoot;
var viteCommand;
function resolveIslandPlugin(islandsSet) {
  return {
    enforce: "pre",
    name: "resolve-islands",
    configResolved(config) {
      viteRoot = config.root;
      viteCommand = config.command;
    },
    load(id) {
      if (id.endsWith("?island") || id.endsWith("?client")) {
        const [idWithNoParam] = id.split("?");
        const islandModuleImportPath = `${idWithNoParam}?client-entry`;
        const componentExtension = path.extname(idWithNoParam);
        const componentFilenameWithNoExtension = path.basename(
          idWithNoParam,
          componentExtension
        );
        const modulePath = idWithNoParam.replace(`${viteRoot}/`, "");
        const moduleId = (viteCommand === "serve" ? idWithNoParam : modulePath).concat("?client-entry");
        if (islandsSet) {
          islandsSet.add(moduleId);
        }
        return `
            const moduleId = '${moduleId}';

            const lazyComponent = () => import('${islandModuleImportPath}');
            lazyComponent.moduleName = '${componentFilenameWithNoExtension}';
            lazyComponent.moduleId = moduleId;

            export default lazyComponent;
          `;
      }
      return null;
    }
  };
}
var clientRenderIsland = "import type { RenderableIsland } from '@hubspot/cms-components';\nimport * as cmsComponents from '@hubspot/cms-components';\nimport { ClientRenderContextProvider } from '@hubspot/cms-components';\nimport { Suspense } from 'react';\nimport ReactDOMClient from 'react-dom/client';\n\nconst buildIslandIdentifierPrefix =\n  cmsComponents.buildIslandIdentifierPrefix || ((id) => id);\n\nexport function clientRenderIsland(\n  renderableIsland: RenderableIsland,\n  Component: React.ComponentType<any>\n) {\n  const {\n    island,\n    rootElement,\n    postHydration,\n    pageUrl,\n    islands,\n    basePath,\n    WrapperModule,\n  } = renderableIsland;\n  let reactRoot: any;\n\n  const rootOptions = {\n    // Ensure useId is unique across island roots\n    identifierPrefix: buildIslandIdentifierPrefix(renderableIsland.island.id),\n  };\n\n  let innerComponent = <Component islandId={island.id} {...island.props} />;\n  if (WrapperModule) {\n    innerComponent = <WrapperModule>{innerComponent}</WrapperModule>;\n  }\n\n  const elementsToHydrate = (\n    <Suspense fallback={`client hydrate fail/waiting for ${island.id}`}>\n      <ClientRenderContextProvider\n        pageUrl={pageUrl}\n        islands={islands}\n        onTopLevelHydrationFinish={postHydration}\n        island={island}\n        basePath={basePath}\n      >\n        {innerComponent}\n      </ClientRenderContextProvider>\n    </Suspense>\n  );\n\n  if (island.clientOnly) {\n    reactRoot = ReactDOMClient.createRoot(rootElement, rootOptions);\n    reactRoot.render(elementsToHydrate);\n  } else {\n    reactRoot = ReactDOMClient.hydrateRoot(\n      rootElement,\n      elementsToHydrate,\n      rootOptions\n    );\n  }\n  return reactRoot;\n}\n";
var virtualClientRenderIslandModuleId = "virtual:clientRenderIsland.tsx";
function clientIslandEntryPlugin() {
  return {
    enforce: "pre",
    name: "client-island-entry-plugin",
    resolveId(id) {
      if (id === virtualClientRenderIslandModuleId) {
        return virtualClientRenderIslandModuleId;
      }
      return null;
    },
    load(id) {
      if (id.endsWith("?client-entry")) {
        const [idWithNoParam] = id.split("?");
        return `
            import { clientRenderIsland } from '${virtualClientRenderIslandModuleId}';
            import Component from '${idWithNoParam}';

            export function render(island) {
              return clientRenderIsland(island, Component)
            }

            export default Component;
          `;
      }
      if (id === virtualClientRenderIslandModuleId) {
        return clientRenderIsland;
      }
      return null;
    }
  };
}

// ../cms-js-internal/dist/index.js
import * as dotProp from "dot-prop";
import * as parser from "@babel/parser";
import _traverse from "@babel/traverse";
import * as t from "@babel/types";
import * as cmsComponents from "@hubspot/cms-components";
var { setProperty, getProperty, hasProperty } = dotProp;
function noncePlaceholderPlugin() {
  const HS_DEPLOYED = process.env.AWS_EXECUTION_ENV != null || process.env.HS_DEPLOYED === "true";
  return {
    name: "hs-nonce-placeholder",
    enforce: "post",
    apply() {
      return HS_DEPLOYED;
    },
    transformIndexHtml(html) {
      const regex = /<(style|script|link) (.*)>/gi;
      const replacer = (_, p1, p2) => {
        if (p1 === "style" || p1 === "script" || // if link, only nonce for stylesheet
        p1 === "link" && p2.includes('rel="stylesheet"')) {
          const noncePlaceholderValue = p1 === "script" ? "hs-random-nonce" : "hs-random-style-nonce";
          p2 = `nonce="${noncePlaceholderValue}" ${p2}`;
        }
        return `<${p1} ${p2}>`;
      };
      return html.replace(regex, replacer);
    }
  };
}
var traverse = _traverse.default;
var CMS_MODULE_COMPONENT_NAME = "Module";
var DND_AREA_COMPONENT_NAME = "DndArea";
var PLUGIN_NAME = "findCmsModules";
function findCmsModules(buildContentDescriptors = {}) {
  let config;
  return {
    enforce: "pre",
    name: "findCmsModules",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    transform(code, id) {
      const moduleInfo = this.getModuleInfo(id);
      if (!shouldAnalyzeModule(config, moduleInfo, code))
        return null;
      const contentDescriptors = analyzeSourceCodeUsages(
        this,
        moduleInfo,
        config,
        code
      );
      if (Object.keys(contentDescriptors.dndAreas).length > 0 || Object.keys(contentDescriptors.modules).length > 0) {
        return {
          meta: {
            findCmsModules: contentDescriptors
          }
        };
      }
    },
    buildEnd(error) {
      if (error)
        throw error;
      const entryPoints = getEntryPoints(this, config);
      const entryPointCmsModuleMap = buildEntryPointsCmsModuleMap(
        this,
        entryPoints
      );
      const relativeEntryPointCmsModuleMap = convertEntryPointPathsToRelative(
        config,
        entryPointCmsModuleMap
      );
      const entryPointIslandCmsModuleMap = buildEntryPointIslandsCmsModuleMap(
        this,
        entryPoints
      );
      const relativeEntryPointIslandCmsModuleMap = convertEntryPointIslandPathsToRelative(
        config,
        entryPointIslandCmsModuleMap
      );
      if (Object.keys(relativeEntryPointIslandCmsModuleMap).length > 0) {
        this.error(`
          Error: <Module /> cannot be used within <Island />
          Found invalid usages:
          ${JSON.stringify(relativeEntryPointIslandCmsModuleMap, null, 2)}
          `);
      }
      const modulesWithinModules = filterEntryPointsToModules(
        relativeEntryPointCmsModuleMap
      );
      if (Object.keys(modulesWithinModules).length > 0) {
        this.error(`
          Error: <Module /> can only be used in React Partials
          Found invalid usages:
          ${JSON.stringify(modulesWithinModules, null, 2)}
        `);
      }
      Object.assign(buildContentDescriptors, relativeEntryPointCmsModuleMap);
    }
  };
}
function convertEntryPointPathsToRelative(config, entryPointsCmsModuleMap) {
  const relativeEntries = Object.entries(entryPointsCmsModuleMap).map(
    ([entryPointPath, cmsModules]) => {
      return [toRelativePath(config, entryPointPath), cmsModules];
    }
  );
  return Object.fromEntries(relativeEntries);
}
function convertEntryPointIslandPathsToRelative(config, entryPointsCmsModuleMap) {
  const relativeEntries = Object.entries(entryPointsCmsModuleMap).map(
    ([entryPointPath, islandContentDescriptors]) => {
      const islandCmsModuleUsage = Object.fromEntries(
        Object.entries(islandContentDescriptors).map(
          ([islandPath, contentDescriptors]) => {
            return [
              toRelativePath(config, islandPath).replace("?client-entry", ""),
              contentDescriptors
            ];
          }
        )
      );
      return [toRelativePath(config, entryPointPath), islandCmsModuleUsage];
    }
  );
  return Object.fromEntries(relativeEntries);
}
function toRelativePath(config, path4) {
  return path4.replace(`${config.root}/`, "");
}
function shouldAnalyzeModule(config, moduleInfo, code) {
  const [fileId, __] = moduleInfo.id.split("?");
  const isExternal = config.command !== "serve" && moduleInfo.isExternal;
  return (
    // analyze customer code only
    !isExternal && moduleInfo.id.startsWith(config.root) && // jsx files that contain "Module" / "DndArea"
    (fileId.endsWith(".tsx") || fileId.endsWith(".jsx")) && (code.includes(CMS_MODULE_COMPONENT_NAME) || code.includes(DND_AREA_COMPONENT_NAME))
  );
}
function getEntryPoints(ctx, config) {
  return Array.from(ctx.getModuleIds()).filter((moduleId) => moduleId.startsWith(config.root)).map((moduleId) => ctx.getModuleInfo(moduleId)).filter((moduleInfo) => moduleInfo.isEntry);
}
function buildEntryPointsCmsModuleMap(ctx, entryPoints) {
  const entryPointCmsModuleUsage = {};
  for (const entryPoint of entryPoints) {
    const result = findCmsModuleUsages(ctx, entryPoint.id);
    if (result) {
      entryPointCmsModuleUsage[entryPoint.id] = result;
    }
  }
  return entryPointCmsModuleUsage;
}
function buildEntryPointIslandsCmsModuleMap(ctx, entryPoints) {
  const entryPointIslandsCmsModuleMap = {};
  for (const entryPoint of entryPoints) {
    const result = findIslandCmsModuleUsage(ctx, entryPoint.id);
    if (result) {
      entryPointIslandsCmsModuleMap[entryPoint.id] = result;
    }
  }
  return entryPointIslandsCmsModuleMap;
}
function analyzeSourceCodeUsages(ctx, moduleInfo, config, code) {
  const sourceAst = parser.parse(code, {
    sourceType: "module",
    plugins: ["jsx", "typescript"]
  });
  const contentDescriptors = { modules: {}, dndAreas: {} };
  let moduleComponentLocalImportName = CMS_MODULE_COMPONENT_NAME;
  let dndAreaComponentLocalImportName = DND_AREA_COMPONENT_NAME;
  traverse(sourceAst, {
    ImportDeclaration(path4) {
      if (t.isStringLiteral(path4.node.source, {
        value: "@hubspot/cms-components"
      })) {
        for (const specifier of path4.node.specifiers) {
          if (t.isImportSpecifier(specifier) && t.isIdentifier(specifier.imported, {
            name: CMS_MODULE_COMPONENT_NAME
          })) {
            moduleComponentLocalImportName = specifier.local.name;
          }
          if (t.isImportSpecifier(specifier) && t.isIdentifier(specifier.imported, {
            name: DND_AREA_COMPONENT_NAME
          })) {
            dndAreaComponentLocalImportName = specifier.local.name;
          }
        }
      }
    },
    JSXOpeningElement(path4) {
      if (t.isJSXIdentifier(path4.node.name, {
        name: moduleComponentLocalImportName
      })) {
        let cmsModuleName;
        let cmsModulePath;
        let cmsModuleLabel;
        for (const prop of path4.node.attributes) {
          if (t.isJSXAttribute(prop) && t.isJSXIdentifier(prop.name, { name: "name" }) && t.isStringLiteral(prop.value)) {
            cmsModuleName = prop.value.value;
            continue;
          }
          if (t.isJSXAttribute(prop) && t.isJSXIdentifier(prop.name, { name: "path" }) && t.isStringLiteral(prop.value)) {
            cmsModulePath = prop.value.value;
            continue;
          }
          if (t.isJSXAttribute(prop) && t.isJSXIdentifier(prop.name, { name: "label" }) && t.isStringLiteral(prop.value)) {
            cmsModuleLabel = prop.value.value;
            continue;
          }
          ctx.error(
            new Error(
              `Error: ${moduleInfo.id.replace(config.root, "")}:${prop.loc.start.line} "name" and "path" must be primitive strings`
            )
          );
        }
        const cmsModuleProps = {
          name: cmsModuleName,
          path: cmsModulePath
        };
        if (cmsModuleLabel) {
          cmsModuleProps.label = cmsModuleLabel;
        }
        if (Object.hasOwn(contentDescriptors.modules, cmsModuleProps.name)) {
          ctx.error(
            new Error(
              `Error: multiple <${CMS_MODULE_COMPONENT_NAME} /> with duplicate name: ${cmsModuleProps.name}`
            )
          );
        }
        contentDescriptors.modules[cmsModuleProps.name] = cmsModuleProps;
      }
      if (t.isJSXIdentifier(path4.node.name, {
        name: dndAreaComponentLocalImportName
      })) {
        let dndAreaName;
        for (const prop of path4.node.attributes) {
          if (t.isJSXAttribute(prop) && t.isJSXIdentifier(prop.name, { name: "name" }) && t.isStringLiteral(prop.value)) {
            dndAreaName = prop.value.value;
            continue;
          }
          ctx.error(
            new Error(
              `Error: ${moduleInfo.id.replace(config.root, "")}:${prop.loc.start.line} "name" must a primitive string`
            )
          );
        }
        const dndArea = {
          name: dndAreaName
        };
        if (Object.hasOwn(contentDescriptors.dndAreas, dndArea.name)) {
          ctx.error(
            new Error(
              `Error: multiple <${DND_AREA_COMPONENT_NAME} /> with duplicate name: ${dndArea.name}`
            )
          );
        }
        contentDescriptors.dndAreas[dndArea.name] = dndArea;
      }
    }
  });
  return contentDescriptors;
}
function findCmsModuleUsages(ctx, moduleId, processed = /* @__PURE__ */ new Set(), result = {}) {
  if (Object.hasOwn(result, moduleId)) {
    return result[moduleId];
  }
  const moduleInfo = ctx.getModuleInfo(moduleId);
  let entryPointContentDescriptors = null;
  if (Object.hasOwn(moduleInfo.meta, PLUGIN_NAME)) {
    entryPointContentDescriptors = {
      ...entryPointContentDescriptors,
      ...moduleInfo.meta[PLUGIN_NAME]
    };
  }
  for (const importedId of [
    ...moduleInfo.importedIds,
    ...moduleInfo.dynamicallyImportedIds
  ]) {
    if (processed.has(importedId)) {
      continue;
    }
    const importedResult = findCmsModuleUsages(
      ctx,
      importedId,
      processed,
      result
    );
    if (importedResult) {
      entryPointContentDescriptors = {
        ...entryPointContentDescriptors,
        ...importedResult
      };
    }
  }
  if (entryPointContentDescriptors) {
    result[moduleId] = entryPointContentDescriptors;
  }
  processed.add(moduleId);
  return entryPointContentDescriptors;
}
function findIslandCmsModuleUsage(ctx, moduleId, processedIslands = /* @__PURE__ */ new Set(), islandModuleResults = {}, processed = /* @__PURE__ */ new Set(), results = {}) {
  processedIslands.add(moduleId);
  if (Object.hasOwn(islandModuleResults, moduleId)) {
    return islandModuleResults[moduleId];
  }
  const moduleInfo = ctx.getModuleInfo(moduleId);
  let resultForModuleId = {};
  if (moduleInfo.id.endsWith("?client-entry")) {
    const mergedDataDependencies = findCmsModuleUsages(
      ctx,
      moduleInfo.id,
      processed,
      results
    );
    if (mergedDataDependencies) {
      resultForModuleId[moduleInfo.id] = mergedDataDependencies;
    }
  }
  for (const importedId of [
    ...moduleInfo.importedIds,
    ...moduleInfo.dynamicallyImportedIds
  ]) {
    if (processedIslands.has(importedId)) {
      continue;
    }
    const importerCmsModuleUsageResult = findIslandCmsModuleUsage(
      ctx,
      importedId,
      processedIslands,
      islandModuleResults,
      processed,
      results
    );
    if (importerCmsModuleUsageResult) {
      resultForModuleId = {
        ...resultForModuleId,
        ...importerCmsModuleUsageResult
      };
    }
  }
  if (Object.keys(resultForModuleId).length > 0) {
    islandModuleResults[moduleId] = resultForModuleId;
    return resultForModuleId;
  }
  return null;
}
function filterEntryPointsToModules(entryPointCmsModuleMap) {
  return Object.fromEntries(
    Object.entries(entryPointCmsModuleMap).filter(
      ([entryPoint]) => entryPoint.startsWith("components/modules/")
    )
  );
}
var {
  createServerRenderContextV2: createServerRenderContextV22,
  createServerRenderContext: createServerRenderContext2,
  renderServerSidePropsWithAsyncLocalStoreContext
} = cmsComponents;

// src/createViteDevServer.ts
import { default as mkcert } from "vite-plugin-mkcert";
import { viteCommonjs } from "@originjs/vite-plugin-commonjs";

// src/plugins/devSecretsPlugin.ts
function devSecretsPlugin(secretNames = []) {
  return {
    name: "dev-secrets",
    config: () => {
      return {
        define: {
          "import.meta.env.secretNames": secretNames
        }
      };
    }
  };
}

// src/plugins/cmsComponentsShimPlugin.ts
function cmsComponentsShimPlugin() {
  return {
    name: "cms-components-shim",
    resolveId(id) {
      if (id === "@hubspot/cms-components" || id.startsWith("@hubspot/cms-components/")) {
        return `\0${id}`;
      }
      return null;
    },
    load(id) {
      if (id === "\0@hubspot/cms-components") {
        return `
          export const HSEnvironment = {};
          export const Hublet = {};
          export const createEmptyServerRenderContext = () => ({});
          export const buildStaticEnvConfig = () => ({});
          export const initConfigSingletonFromJSON = () => ({});
          export default {};
        `;
      }
      if (id === "\0@hubspot/cms-components/config") {
        return `
          export const EnvironmentConfig = {};
          export const initConfigSingletonFromJSON = () => ({});
          export default {};
        `;
      }
      if (id === "\0@hubspot/cms-components/fields") {
        return `
          export const Field = {};
          export const traverseFieldsJSON = () => ({});
          export default {};
        `;
      }
      if (id.startsWith("\0@hubspot/cms-components/")) {
        return "export default {};";
      }
      return null;
    }
  };
}

// src/createViteDevServer.ts
import { readFileSync } from "fs";
import { join } from "path";
function getPackageJson(packagePath2) {
  return JSON.parse(readFileSync(join(packagePath2, "package.json")).toString());
}
function getDepsForPackage(packagePath2) {
  const packageJson = getPackageJson(packagePath2);
  return packageJson.dependencies ? Object.keys(packageJson.dependencies) : [];
}
function getDepsForPackageIfExists(packagePath2) {
  try {
    return getDepsForPackage(packagePath2);
  } catch (e) {
    console.log("No package.json at ", packagePath2);
    return [];
  }
}
async function createViteDevServer(webRoot, port, sslEnabled, domainsToProxy = [], jsRenderingGates, secretNames) {
  const additionalMkcertHosts = domainsToProxy.map((proxyDomain) => [
    `${proxyDomain}.localhost`,
    `${proxyDomain}.hslocal.net`
  ]).flat();
  if (process.env.VITE_ORIGIN) {
    console.log(`
Custom origin: ${process.env.VITE_ORIGIN}
`);
  }
  const origin = process.env.VITE_ORIGIN ?? (sslEnabled ? `https://hslocal.net:${port}` : `http://hslocal.net:${port}`);
  const consumerDeps = getDepsForPackageIfExists(webRoot);
  const isProjectWithReact = consumerDeps.includes("@hubspot/cms-components");
  const componentsShimPlugin = isProjectWithReact ? null : cmsComponentsShimPlugin();
  const ssrAndOptimizeDep = isProjectWithReact ? {
    ssr: {
      // TODO: might need more entries here to get things to resolve through
      // resolveWebRootDepsPlugin
      noExternal: "@hubspot/cms-components"
    },
    resolve: {
      conditions: ["server"],
      dedupe: [
        "react",
        "react-dom",
        "@hubspot/cms-components",
        "styled-jsx"
      ]
    },
    optimizeDeps: {
      include: ["react", "react-dom", "react-dom/client"]
    }
  } : {};
  const reactAndIslandsPlugins = isProjectWithReact || process.env.VITEST ? [
    react({
      babel: {
        plugins: [
          "babel-plugin-styled-components",
          "styled-jsx/babel",
          "macros"
        ]
      }
    }),
    clientIslandEntryPlugin(),
    resolveIslandPlugin(),
    jsRenderingGates.includes("CMS:JSRenderer:RemoveCjsPlugin") ? null : viteCommonjs(),
    devSecretsPlugin(secretNames),
    noncePlaceholderPlugin()
  ] : [];
  const viteConfig = {
    appType: "custom",
    server: {
      middlewareMode: true,
      host: "hslocal.net",
      origin,
      hmr: {
        protocol: sslEnabled ? "wss" : void 0
      }
    },
    root: webRoot,
    ...ssrAndOptimizeDep,
    plugins: [
      jsRenderingGates.includes("CMS:JSRenderer:AnalyzeCmsModules") ? findCmsModules() : null,
      sslEnabled ? mkcert({ hosts: additionalMkcertHosts }) : null,
      componentsShimPlugin,
      ...reactAndIslandsPlugins
    ],
    css: {
      postcss: webRoot
    },
    envDir: webRoot,
    envPrefix: "HS_"
  };
  return createViteServer(viteConfig);
}
var createViteDevServer_default = createViteDevServer;

// src/lib/packagePath.ts
import path2 from "path";
import url from "url";
import { normalizePath } from "vite";
function packagePath(metaUrl, projectPath) {
  if (true) {
    return normalizePath(
      path2.resolve(path2.dirname(url.fileURLToPath(metaUrl)), projectPath)
    );
  }
  const parentDirPath = normalizePath(path2.dirname(url.fileURLToPath(metaUrl)));
  const subPath = parentDirPath.replace(/^.+cms-dev-server\/src\//, "");
  const subPathParentDirs = subPath.split("/").map(() => "..");
  return path2.resolve(
    path2.dirname(url.fileURLToPath(metaUrl)),
    path2.join(...subPathParentDirs, projectPath)
  );
}

// src/generateJsonFromJsx.ts
var internalSsrPath = packagePath(import.meta.url, "internalSsr");
async function writeFile(filePath, data) {
  try {
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
    console.log("File has been written successfully to: ", filePath);
  } catch (error) {
    console.error("Error writing to file", { filePath, error });
  }
}
async function createJsonFiles(webRoot, data) {
  const fieldsFilePath = path3.join(webRoot, "tmp-fields.json");
  const metaFilePath = path3.join(webRoot, "tmp-meta.json");
  const { fields, meta } = data;
  if (!fields || !meta) {
    throw new Error("Fields or meta exports are missing");
  }
  await writeFile(fieldsFilePath, fields);
  await writeFile(metaFilePath, meta);
}
async function transformJsxToJson() {
  const webRoot = process.argv[2];
  if (!webRoot) {
    throw new Error("Path to module directory not provided");
  }
  const moduleFiles = await fs.readdir(webRoot);
  const indexFile = moduleFiles.find((file) => file.includes("index"));
  if (!indexFile) {
    throw new Error(
      'Index file that contains "fields" and "meta" exports not found'
    );
  }
  const modulePath = path3.join(webRoot, indexFile);
  const absoluteWebRoot = normalizePath2(path3.resolve(process.cwd(), webRoot));
  const viteServer = await createViteDevServer_default(
    absoluteWebRoot,
    3e3,
    false,
    [],
    [],
    []
  );
  try {
    const { fields, meta } = await viteServer.ssrLoadModule(modulePath);
    const { renderFieldsToJson } = await viteServer.ssrLoadModule(internalSsrPath);
    const fieldsJson = renderFieldsToJson(fields, meta.label);
    await createJsonFiles(webRoot, { fields: fieldsJson, meta });
  } catch (error) {
    throw new Error("Failed to generate JSON from JSX: ", error);
  }
}
(async () => {
  try {
    await transformJsxToJson();
    process.exit(0);
  } catch (error) {
    console.error("An error occurred:", error);
    process.exit(1);
  }
})().catch((error) => {
  throw error;
});
export {
  createJsonFiles,
  transformJsxToJson,
  writeFile
};
