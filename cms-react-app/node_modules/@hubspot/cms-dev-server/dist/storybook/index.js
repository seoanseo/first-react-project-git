// src/storybook/moduleStory.tsx
import { useEffect } from "react";

// ../cms-js-internal/dist/types-CnX5J5m1.js
function namespaceModulePropsShape(props) {
  const {
    dataQueryResult,
    hublParameters,
    fieldValues: passedFieldValues,
    hublData,
    experimentalHublData,
    moduleName,
    supplementalFieldValues
  } = props;
  const oldPropsShape = { ...props };
  if (oldPropsShape.dataQueryResult) {
    delete oldPropsShape.dataQueryResult;
  }
  if (oldPropsShape.hublParameters) {
    delete oldPropsShape.hublParameters;
  }
  const fieldValues = passedFieldValues || oldPropsShape;
  return {
    ...fieldValues,
    dataQueryResult,
    fieldValues,
    hublParameters,
    hublData,
    experimentalHublData,
    moduleName,
    supplementalFieldValues
  };
}

// ../cms-js-internal/dist/index.js
import * as dotProp from "dot-prop";
import _traverse from "@babel/traverse";
import { renderToPipeableStream, renderToStaticMarkup } from "react-dom/server";
import * as cmsComponents from "@hubspot/cms-components";
import { isValidElement, cloneElement } from "react";
var { setProperty, getProperty, hasProperty } = dotProp;
var traverse = _traverse.default;
var {
  createServerRenderContextV2: createServerRenderContextV22,
  createServerRenderContext: createServerRenderContext2,
  renderServerSidePropsWithAsyncLocalStoreContext
} = cmsComponents;
function renderFieldsJSX(fieldsJSX) {
  let moduleJson;
  const outputCallback = (callbackJson) => {
    moduleJson = callbackJson;
  };
  renderToStaticMarkup(
    cloneElement(fieldsJSX, {
      outputCallback
    })
  );
  if (!moduleJson) {
    throw new Error("couldn't render module fields definition to fields.json");
  }
  return moduleJson;
}
function renderFieldsToJson(fields, moduleName) {
  let fieldsJSON;
  try {
    if (isValidElement(fields)) {
      fieldsJSON = renderFieldsJSX(fields);
    } else if (Array.isArray(fields)) {
      fieldsJSON = fields;
    } else {
      throw new Error(
        `Couldn't recognize \`fields\` value for module ${moduleName}`
      );
    }
    return fieldsJSON;
  } catch (e2) {
    e2.message = `Error when rendering fields for ${moduleName}: ${e2.message}`;
    throw e2;
  }
}

// src/storybook/getFieldsArgTypes.ts
function getFieldsArgTypes(fieldsJson, currentPathSegments = []) {
  let resultArgTypes = {};
  for (const field of fieldsJson) {
    const fullFieldName = [...currentPathSegments, field.name].join(".");
    switch (field.type) {
      case "group": {
        if (!field.children) {
          continue;
        }
        const groupResult = getFieldsArgTypes(field.children, [
          ...currentPathSegments,
          field.name
        ]);
        resultArgTypes = {
          ...resultArgTypes,
          ...groupResult
        };
        break;
      }
      case "boolean": {
        resultArgTypes[fullFieldName] = {
          control: "boolean",
          defaultValue: field.default
        };
        break;
      }
      case "text": {
        resultArgTypes[fullFieldName] = {
          control: "text",
          defaultValue: field.default
        };
        break;
      }
      case "number": {
        resultArgTypes[fullFieldName] = {
          control: "number",
          defaultValue: field.default
        };
        break;
      }
      case "choice": {
        const options = field.choices ? field.choices.map((choice) => choice[1]) : [];
        resultArgTypes[fullFieldName] = {
          control: "select",
          defaultValue: field.default,
          options
        };
        break;
      }
      default: {
        resultArgTypes[fullFieldName] = {
          control: "object",
          defaultValue: field.default
        };
        break;
      }
    }
  }
  return resultArgTypes;
}

// src/storybook/getNestedFieldObjectForArgs.ts
function getNestedFieldObjectForArgs(_args) {
  const result = {};
  for (const argPath in _args) {
    if (Object.prototype.hasOwnProperty.call(_args, argPath)) {
      const argPathSegments = argPath.split(".");
      const nestedSegments = argPathSegments.slice(0, -1);
      const fieldName = argPathSegments[argPathSegments.length - 1];
      const fieldValue = _args[argPath];
      let currentNest = result;
      for (const segment of nestedSegments) {
        if (!Object.prototype.hasOwnProperty.call(currentNest, segment)) {
          currentNest[segment] = {};
        }
        currentNest = currentNest[segment];
      }
      currentNest[fieldName] = fieldValue;
    }
  }
  return result;
}

// src/storybook/moduleStory.tsx
import { jsx } from "react/jsx-runtime";
function moduleArgs(argTypes) {
  const args = {};
  for (const argKey in argTypes) {
    if (Object.hasOwnProperty.call(argTypes, argKey)) {
      args[argKey] = argTypes[argKey].defaultValue;
    }
  }
  return args;
}
function moduleStory(ModuleComponent, fields, storyArgs) {
  const fieldsJSON = renderFieldsToJson(fields, ModuleComponent.name);
  const argTypes = getFieldsArgTypes(fieldsJSON);
  const args = { ...moduleArgs(argTypes), ...storyArgs };
  return {
    render: (_args) => {
      const fieldValues = getNestedFieldObjectForArgs(_args);
      const props = namespaceModulePropsShape(fieldValues);
      return /* @__PURE__ */ jsx(ModuleComponent, { ...props });
    },
    argTypes,
    args
  };
}
function moduleStoryWithIsland(moduleName, fields, storyArgs) {
  if (typeof moduleName !== "string") {
    throw new Error(
      "moduleStoryWithIsland takes a `moduleName` that matches the file or folder name for the module as a string for the first argument, and the module's Fields JSX as the second parameter"
    );
  }
  if (!fields) {
    throw new Error(
      "moduleStoryWithIsland requires a second parameter of the module's fields configuration"
    );
  }
  const fieldsJSON = renderFieldsToJson(fields, moduleName);
  const argTypes = getFieldsArgTypes(fieldsJSON);
  const args = { ...moduleArgs(argTypes), ...storyArgs };
  return {
    argTypes,
    args,
    render: (_args) => {
      const fieldValues = getNestedFieldObjectForArgs(_args);
      const fieldValuesString = JSON.stringify(fieldValues);
      const domain = `${window.location.protocol}//${window.location.hostname.replace("storybook.", "")}:3000`;
      const fieldValuesJson = encodeURIComponent(fieldValuesString);
      const iframeSrc = `${domain}/module/${moduleName}?fields=${fieldValuesJson}`;
      useEffect(() => {
        const existingElement = document.querySelector("#hs-module-iframe");
        if (existingElement) {
          existingElement.setAttribute("src", iframeSrc);
          return () => {
            existingElement.remove();
          };
        }
        const iframeElement = document.createElement("iframe");
        iframeElement.setAttribute("src", iframeSrc);
        iframeElement.setAttribute("id", "hs-module-iframe");
        iframeElement.setAttribute(
          "style",
          `border: none;width: 100%;height: 100%;overflow: auto;position: absolute;left: 0;top: 0;`
        );
        document.querySelector("#storybook-root").appendChild(iframeElement);
        return () => {
          iframeElement.remove();
        };
      }, [iframeSrc]);
      return /* @__PURE__ */ jsx("div", {});
    }
  };
}
export {
  moduleStory,
  moduleStoryWithIsland
};
