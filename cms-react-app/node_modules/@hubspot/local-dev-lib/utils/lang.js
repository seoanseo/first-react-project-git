"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLangData = exports.i18n = exports.interpolate = void 0;
const en_json_1 = __importDefault(require("../lang/en.json"));
const LANGUAGES = {
    en: en_json_1.default,
};
const MISSING_LANGUAGE_DATA_PREFIX = '[Missing language data]';
let languageObj;
function loadLanguageForLocale() {
    if (languageObj)
        return;
    try {
        const nodeLocale = Intl.DateTimeFormat()
            .resolvedOptions()
            .locale.split('-')[0];
        languageObj = LANGUAGES[nodeLocale] || LANGUAGES.en;
    }
    catch (e) {
        throw new Error(`Error loading language data: ${e}`);
    }
}
function getTextValue(lookupDotNotation) {
    const lookupProps = lookupDotNotation.split('.');
    const missingTextData = `${MISSING_LANGUAGE_DATA_PREFIX}: ${lookupDotNotation}`;
    let textValue = languageObj;
    let previouslyCheckedProp = lookupProps[0];
    lookupProps.forEach(prop => {
        previouslyCheckedProp = prop;
        if (typeof textValue === 'object') {
            textValue = textValue[prop];
        }
        else {
            console.debug(`Unable to access language property: ${lookupProps.join('.')}. Failed to access prop "${previouslyCheckedProp}".`);
        }
    });
    if (typeof textValue !== 'string') {
        return missingTextData;
    }
    return textValue;
}
const delimiters = {
    interpolation: {
        start: '{{',
        end: '}}',
    },
};
function generateReplaceFn(matchedText, startIndex, replacementString) {
    return function (currentStringValue) {
        return `${currentStringValue.slice(0, startIndex)}${replacementString || ''}${currentStringValue.slice(startIndex + matchedText.length)}`;
    };
}
function interpolate(stringValue, interpolationData) {
    const interpolationIdentifierRegEx = new RegExp(`${delimiters.interpolation.start}(.*?)${delimiters.interpolation.end}`, 'g');
    const replaceQueue = [];
    let match;
    // while & reduce necessary because RegExp.exec is stateful and only runs
    // from beginning to end of string
    while ((match = interpolationIdentifierRegEx.exec(stringValue)) != null) {
        const { 0: matchedText, 1: rawIdentifier, index } = match;
        const identifier = rawIdentifier.trim();
        if (identifier) {
            replaceQueue.unshift(generateReplaceFn(matchedText, index, interpolationData[identifier]));
        }
    }
    const compiledString = replaceQueue.reduce((currentValue, replaceFn) => replaceFn(currentValue), stringValue);
    return compiledString;
}
exports.interpolate = interpolate;
function i18n(lookupDotNotation, options = {}) {
    if (!languageObj) {
        loadLanguageForLocale();
    }
    if (typeof lookupDotNotation !== 'string') {
        throw new Error(`i18n must be passed a string value for lookupDotNotation, received ${typeof lookupDotNotation}`);
    }
    const textValue = getTextValue(lookupDotNotation);
    const shouldInterpolate = !textValue.startsWith(MISSING_LANGUAGE_DATA_PREFIX);
    return shouldInterpolate ? interpolate(textValue, options) : textValue;
}
exports.i18n = i18n;
const setLangData = (newLocale, newLangObj) => {
    languageObj = newLangObj;
};
exports.setLangData = setLangData;
