"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanupTmpDirSync = exports.createTmpDirSync = exports.isConvertableFieldJs = exports.FieldsJs = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const escapeRegExp_1 = require("../escapeRegExp");
const modules_1 = require("../../utils/cms/modules");
const logger_1 = require("../logger");
const lang_1 = require("../../utils/lang");
const i18nKey = 'lib.cms.handleFieldsJs';
class FieldsJs {
    projectDir;
    filePath;
    rootWriteDir;
    rejected;
    fieldOptions;
    outputPath;
    toJSON;
    constructor(projectDir, filePath, rootWriteDir, fieldOptions = '') {
        this.projectDir = projectDir;
        this.filePath = filePath;
        this.fieldOptions = fieldOptions;
        this.rejected = false;
        // Create tmpDir if no writeDir is given.
        this.rootWriteDir =
            rootWriteDir === undefined || rootWriteDir === null
                ? createTmpDirSync('hubspot-temp-fieldsjs-output-')
                : rootWriteDir;
    }
    async init() {
        const outputPath = await this.getOutputPathPromise();
        this.outputPath = this.rejected ? undefined : outputPath;
        return this;
    }
    // Converts a fields.js file into a fields.json file, writes, and returns of fields.json
    convertFieldsJs(writeDir) {
        const filePath = this.filePath;
        const dirName = path_1.default.dirname(filePath);
        return new Promise((resolve, reject) => {
            const convertFieldsProcess = (0, child_process_1.fork)(path_1.default.join(__dirname, './processFieldsJs.js'), [], {
                cwd: dirName,
                env: {
                    dirName,
                    fieldOptions: this.fieldOptions,
                    filePath,
                    writeDir,
                },
            });
            logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.convertFieldsJs.creating`, {
                pid: convertFieldsProcess.pid || '',
            }));
            convertFieldsProcess.on('message', function (message) {
                if (message.action === 'ERROR') {
                    reject(message.message);
                }
                else if (message.action === 'COMPLETE') {
                    resolve(message.finalPath);
                }
            });
            convertFieldsProcess.on('close', () => {
                logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.convertFieldsJs.terminating`, {
                    pid: convertFieldsProcess.pid || '',
                }));
            });
        }).catch((e) => {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.convertFieldsJs.errors.errorConverting`, { filePath }), { cause: e });
        });
    }
    /**
     * If there has been a fields.json written to the output path, then copy it from the output
     * directory to the project directory, respecting the path within the output directory.
     * Ex: path/to/tmp/example.module/fields.json => path/to/project/example.module/fields.output.json
     */
    saveOutput() {
        if (!this.outputPath || !fs_extra_1.default.existsSync(this.outputPath)) {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.saveOutput.errors.saveFailed`, {
                path: this.filePath,
            }));
        }
        const relativePath = path_1.default.relative(this.rootWriteDir, path_1.default.dirname(this.outputPath));
        const savePath = path_1.default.join(this.projectDir, relativePath, 'fields.output.json');
        try {
            fs_extra_1.default.copyFileSync(this.outputPath, savePath);
        }
        catch (err) {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.saveOutput.errors.saveFailed`, { path: savePath }), { cause: err });
        }
    }
    /**
     * Resolves the relative path to the fields.js within the project directory and returns
     * directory name to write to in rootWriteDir directory.
     *
     * Ex: If rootWriteDir = 'path/to/temp', filePath = 'projectRoot/sample.module/fields.js'. Then getWriteDir() => path/to/temp/sample.module
     */
    getWriteDir() {
        const projectDirRegex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(this.projectDir)}`);
        const relativePath = this.filePath.replace(projectDirRegex, '');
        return path_1.default.dirname(path_1.default.join(this.rootWriteDir, relativePath));
    }
    getOutputPathPromise() {
        const writeDir = this.getWriteDir();
        return this.convertFieldsJs(writeDir).then(outputPath => outputPath);
    }
}
exports.FieldsJs = FieldsJs;
/**
 * Determines if file is a convertable fields.js file i.e., if it is called
 * 'fields.js' and in a root or in a module folder, and if convertFields flag is true.
 */
function isConvertableFieldJs(rootDir, filePath, convertFields = false) {
    const allowedFieldsNames = ['fields.js', 'fields.mjs', 'fields.cjs'];
    const regex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(rootDir)}`);
    const relativePath = path_1.default.dirname(filePath.replace(regex, ''));
    const baseName = path_1.default.basename(filePath);
    const inModuleFolder = (0, modules_1.isModuleFolderChild)({ path: filePath, isLocal: true });
    return !!(convertFields &&
        allowedFieldsNames.includes(baseName) &&
        (inModuleFolder || relativePath == path_1.default.sep));
}
exports.isConvertableFieldJs = isConvertableFieldJs;
// Try creating tempdir
function createTmpDirSync(prefix) {
    let tmpDir;
    try {
        tmpDir = fs_extra_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), prefix));
    }
    catch (err) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.createTmpDirSync.errors.writeFailed`), {
            cause: err,
        });
    }
    return tmpDir;
}
exports.createTmpDirSync = createTmpDirSync;
// Try cleaning up resources from os's tempdir
function cleanupTmpDirSync(tmpDir) {
    fs_extra_1.default.rm(tmpDir, { recursive: true }, err => {
        if (err) {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.cleanupTmpDirSync.errors.deleteFailed`), { cause: err });
        }
    });
}
exports.cleanupTmpDirSync = cleanupTmpDirSync;
