"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractZipArchive = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const os_1 = require("os");
const extract_zip_1 = __importDefault(require("extract-zip"));
const logger_1 = require("./logger");
const lang_1 = require("../utils/lang");
const FileSystemError_1 = require("../models/FileSystemError");
const i18nKey = 'lib.archive';
async function extractZip(name, zip, hideLogs = false) {
    const result = { extractDir: '', tmpDir: '' };
    const TMP_FOLDER_PREFIX = `hubspot-temp-${name}-`;
    if (!hideLogs) {
        logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.extractZip.init`));
    }
    // Write zip to disk
    let tmpZipPath = '';
    try {
        result.tmpDir = await fs_extra_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), TMP_FOLDER_PREFIX));
        tmpZipPath = (0, path_1.join)(result.tmpDir, 'hubspot-temp.zip');
        await fs_extra_1.default.ensureFile(tmpZipPath);
        await fs_extra_1.default.writeFile(tmpZipPath, zip, {
            mode: 0o777,
        });
    }
    catch (err) {
        if (tmpZipPath || result.tmpDir) {
            throw new FileSystemError_1.FileSystemError({ cause: err }, {
                filepath: tmpZipPath || result.tmpDir,
                operation: 'write',
            });
        }
        else {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.extractZip.errors.write`), {
                cause: err,
            });
        }
    }
    // Extract zip
    try {
        const tmpExtractPath = (0, path_1.join)(result.tmpDir, 'extracted');
        await (0, extract_zip_1.default)(tmpZipPath, { dir: tmpExtractPath });
        result.extractDir = tmpExtractPath;
    }
    catch (err) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.extractZip.errors.extract`), {
            cause: err,
        });
    }
    logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.extractZip.success`));
    return result;
}
async function copySourceToDest(src, dest, { sourceDir, includesRootDir = true, hideLogs = false, } = {}) {
    try {
        if (!hideLogs) {
            logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.init`));
        }
        const srcDirPath = [src];
        if (includesRootDir) {
            const files = await fs_extra_1.default.readdir(src);
            const rootDir = files[0];
            if (!rootDir) {
                logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.sourceEmpty`));
                // Create the dest path if it doesn't already exist
                await fs_extra_1.default.ensureDir(dest);
                // No root found so nothing to copy
                return true;
            }
            srcDirPath.push(rootDir);
        }
        if (sourceDir) {
            srcDirPath.push(sourceDir);
        }
        const projectSrcDir = (0, path_1.join)(...srcDirPath);
        await fs_extra_1.default.copy(projectSrcDir, dest);
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.success`));
        return true;
    }
    catch (err) {
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.copySourceToDest.error`, { dest }));
        throw new FileSystemError_1.FileSystemError({ cause: err }, {
            filepath: dest,
            operation: 'write',
        });
    }
}
async function cleanupTempDir(tmpDir) {
    if (!tmpDir)
        return;
    try {
        await fs_extra_1.default.remove(tmpDir);
    }
    catch (e) {
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.cleanupTempDir.error`, { tmpDir }));
    }
}
async function extractZipArchive(zip, name, dest, { sourceDir, includesRootDir, hideLogs } = {}) {
    let success = false;
    if (zip) {
        const { extractDir, tmpDir } = await extractZip(name, zip, hideLogs);
        if (extractDir !== null) {
            success = await copySourceToDest(extractDir, dest, {
                sourceDir,
                includesRootDir,
                hideLogs,
            });
        }
        await cleanupTempDir(tmpDir);
    }
    return success;
}
exports.extractZipArchive = extractZipArchive;
