"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listGithubRepoContents = exports.downloadGithubRepoContents = exports.fetchGitHubRepoContentFromDownloadUrl = exports.cloneGithubRepo = exports.fetchReleaseData = exports.fetchFileFromRepository = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const archive_1 = require("./archive");
const logger_1 = require("./logger");
const github_1 = require("../api/github");
const lang_1 = require("../utils/lang");
const errors_1 = require("../errors");
const i18nKey = 'lib.github';
async function fetchFileFromRepository(repoPath, filePath, ref) {
    try {
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.fetchFileFromRepository.fetching`, {
            path: `${repoPath}/${ref}/${filePath}`,
        }));
        const { data } = await (0, github_1.fetchRepoFile)(repoPath, filePath, ref);
        return data;
    }
    catch (err) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.fetchFileFromRepository.errors.fetchFail`), {
            cause: err,
        });
    }
}
exports.fetchFileFromRepository = fetchFileFromRepository;
// Fetches information about a specific release (Defaults to latest)
async function fetchReleaseData(repoPath, tag) {
    if (tag) {
        tag = tag.trim().toLowerCase();
        if (tag.length && tag[0] !== 'v') {
            tag = `v${tag}`;
        }
    }
    try {
        const { data } = await (0, github_1.fetchRepoReleaseData)(repoPath, tag);
        return data;
    }
    catch (err) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.fetchReleaseData.errors.fetchFail`, {
            tag: tag || 'latest',
        }), { cause: err });
    }
}
exports.fetchReleaseData = fetchReleaseData;
async function downloadGithubRepoZip(repoPath, isRelease = false, options = {}) {
    const { branch, tag } = options;
    try {
        let zipUrl;
        if (isRelease) {
            // If downloading a release, first get the release info using fetchReleaseData().
            // Supports a custom tag, but will default to the latest release
            const releaseData = await fetchReleaseData(repoPath, tag);
            zipUrl = releaseData.zipball_url;
            const { name } = releaseData;
            logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoZip.fetchingName`, { name }));
        }
        else {
            // If downloading a repository, manually construct the zip url. This url supports both branches and tags as refs
            logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoZip.fetching`, { repoPath }));
            const ref = branch || tag;
            zipUrl = `https://api.github.com/repos/${repoPath}/zipball${ref ? `/${ref}` : ''}`;
        }
        const { data } = await (0, github_1.fetchRepoAsZip)(zipUrl);
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoZip.completed`));
        return data;
    }
    catch (err) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoZip.errors.fetchFail`), {
            cause: err,
        });
    }
}
async function cloneGithubRepo(repoPath, dest, options = {}) {
    const { tag, isRelease, branch, sourceDir, type } = options;
    const zip = await downloadGithubRepoZip(repoPath, isRelease, {
        tag,
        branch,
    });
    const repoName = repoPath.split('/')[1];
    const success = await (0, archive_1.extractZipArchive)(zip, repoName, dest, { sourceDir });
    if (success) {
        logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.cloneGithubRepo.success`, {
            type: type || '',
            dest,
        }));
    }
    return success;
}
exports.cloneGithubRepo = cloneGithubRepo;
async function fetchGitHubRepoContentFromDownloadUrl(dest, downloadUrl) {
    const resp = await (0, github_1.fetchRepoFileByDownloadUrl)(downloadUrl);
    const contentType = resp.headers['content-type'];
    let fileContents;
    if (contentType.startsWith('text')) {
        fileContents = Buffer.from(resp.data).toString('utf8');
    }
    else {
        fileContents = resp.data;
    }
    fs_extra_1.default.outputFileSync(dest, fileContents);
}
exports.fetchGitHubRepoContentFromDownloadUrl = fetchGitHubRepoContentFromDownloadUrl;
// Writes files from a public repository to the destination folder
async function downloadGithubRepoContents(repoPath, contentPath, dest, ref, filter) {
    fs_extra_1.default.ensureDirSync(path_1.default.dirname(dest));
    try {
        const { data: contentsResp } = await (0, github_1.fetchRepoContents)(repoPath, contentPath, ref);
        const downloadContent = async (contentPiece) => {
            const { path: contentPiecePath, download_url, type: contentPieceType, } = contentPiece;
            const downloadPath = path_1.default.join(dest, contentPiecePath.replace(contentPath, ''));
            if (filter && !filter(contentPiecePath, downloadPath)) {
                return Promise.resolve();
            }
            logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoContents.downloading`, {
                contentPiecePath,
                downloadUrl: download_url,
                downloadPath,
            }));
            if (contentPieceType === 'dir') {
                const { data: innerDirContent } = await (0, github_1.fetchRepoContents)(repoPath, contentPiecePath, ref);
                await Promise.all(innerDirContent.map(downloadContent));
                return Promise.resolve();
            }
            return fetchGitHubRepoContentFromDownloadUrl(downloadPath, download_url);
        };
        let contentPromises;
        if (Array.isArray(contentsResp)) {
            contentPromises = contentsResp.map(downloadContent);
        }
        else {
            contentPromises = [downloadContent(contentsResp)];
        }
        await Promise.all(contentPromises);
    }
    catch (e) {
        if ((0, errors_1.isSystemError)(e) && e?.error?.message) {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoContents.errors.fetchFail`, {
                errorMessage: e.error.message,
            }), { cause: e });
        }
        throw e;
    }
}
exports.downloadGithubRepoContents = downloadGithubRepoContents;
// Lists content from a public repository at the specified path
async function listGithubRepoContents(repoPath, contentPath, fileFilter) {
    try {
        const { data: contentsResp } = await (0, github_1.fetchRepoContents)(repoPath, contentPath);
        const filteredFiles = fileFilter && fileFilter != undefined
            ? contentsResp.filter(item => item.type === fileFilter)
            : contentsResp;
        return filteredFiles;
    }
    catch (e) {
        if ((0, errors_1.isHubSpotHttpError)(e) && e.data.message) {
            throw new Error((0, lang_1.i18n)(`${i18nKey}.downloadGithubRepoContents.errors.fetchFail`, {
                errorMessage: e.data.message,
            }));
        }
        throw e;
    }
}
exports.listGithubRepoContents = listGithubRepoContents;
