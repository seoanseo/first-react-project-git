"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.walk = exports.flattenAndRemoveSymlinks = exports.getFileInfoAsync = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const files_1 = require("../constants/files");
const FileSystemError_1 = require("../models/FileSystemError");
function getFileInfoAsync(dir, file) {
    return new Promise((resolve, reject) => {
        const filepath = path_1.default.join(dir, file);
        fs_1.default.lstat(filepath, (error, stats) => {
            if (error) {
                reject(error);
            }
            let type = files_1.STAT_TYPES.FILE;
            if (stats.isSymbolicLink()) {
                type = files_1.STAT_TYPES.SYMBOLIC_LINK;
            }
            else if (stats.isDirectory()) {
                type = files_1.STAT_TYPES.DIRECTORY;
            }
            resolve({ filepath, type });
        });
    });
}
exports.getFileInfoAsync = getFileInfoAsync;
function flattenAndRemoveSymlinks(filesData) {
    return filesData.reduce((acc, fileData) => {
        switch (fileData.type) {
            case files_1.STAT_TYPES.FILE:
                return acc.concat(fileData.filepath);
            case files_1.STAT_TYPES.DIRECTORY:
                return acc.concat(fileData.files || []);
            case files_1.STAT_TYPES.SYMBOLIC_LINK:
                return acc;
            default:
                return acc;
        }
    }, []);
}
exports.flattenAndRemoveSymlinks = flattenAndRemoveSymlinks;
const generateRecursiveFilePromise = async (dir, file) => {
    return getFileInfoAsync(dir, file).then(fileData => {
        return new Promise(resolve => {
            if (fileData.type === files_1.STAT_TYPES.DIRECTORY) {
                walk(fileData.filepath).then(files => {
                    resolve({ ...fileData, files });
                });
            }
            else {
                resolve(fileData);
            }
        });
    });
};
async function walk(dir) {
    function processFiles(files) {
        return Promise.all(files.map(file => generateRecursiveFilePromise(dir, file)));
    }
    return fs_1.default.promises
        .readdir(dir)
        .then(processFiles)
        .then(flattenAndRemoveSymlinks)
        .catch(err => {
        throw new FileSystemError_1.FileSystemError({ cause: err });
    });
}
exports.walk = walk;
