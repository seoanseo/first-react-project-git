"use strict";
// FILE MANAGER - not to be confused with fileMapper.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadFileOrFolder = exports.uploadFolder = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const fileManager_1 = require("../api/fileManager");
const fs_1 = require("./fs");
const logger_1 = require("./logger");
const ignoreRules_1 = require("./ignoreRules");
const http_1 = require("../http");
const escapeRegExp_1 = require("./escapeRegExp");
const path_2 = require("./path");
const lang_1 = require("../utils/lang");
const errors_1 = require("../errors");
const FileSystemError_1 = require("../models/FileSystemError");
const i18nKey = 'lib.fileManager';
async function uploadFolder(accountId, src, dest) {
    const regex = new RegExp(`^${(0, escapeRegExp_1.escapeRegExp)(src)}`);
    const files = await (0, fs_1.walk)(src);
    const filesToUpload = files.filter((0, ignoreRules_1.createIgnoreFilter)(false));
    const len = filesToUpload.length;
    for (let index = 0; index < len; index++) {
        const file = filesToUpload[index];
        const relativePath = file.replace(regex, '');
        const destPath = (0, path_2.convertToUnixPath)(path_1.default.join(dest, relativePath));
        logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.uploadStarted`, {
            file,
            destPath,
            accountId,
        }));
        try {
            await (0, fileManager_1.uploadFile)(accountId, file, destPath);
            logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.uploadSuccess`, { file, destPath }));
        }
        catch (err) {
            if ((0, errors_1.isHubSpotHttpError)(err)) {
                err.updateContext({
                    filepath: file,
                    dest: destPath,
                });
                throw err;
            }
            throw new Error((0, lang_1.i18n)(`${i18nKey}.errors.uploadFailed`, {
                file,
                destPath,
            }));
        }
    }
}
exports.uploadFolder = uploadFolder;
async function skipExisting(overwrite, filepath) {
    if (overwrite) {
        return false;
    }
    if (await fs_extra_1.default.pathExists(filepath)) {
        logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.skippedExisting`, { filepath }));
        return true;
    }
    return false;
}
async function downloadFile(accountId, file, dest, overwrite) {
    const fileName = `${file.name}.${file.extension}`;
    const destPath = (0, path_2.convertToLocalFileSystemPath)(path_1.default.join(dest, fileName));
    if (await skipExisting(overwrite || false, destPath)) {
        return;
    }
    await http_1.http.getOctetStream(accountId, {
        baseURL: file.url,
        url: '',
    }, destPath);
}
async function fetchAllPagedFiles(accountId, folderId, includeArchived) {
    let totalFiles = null;
    let files = [];
    let count = 0;
    let offset = 0;
    while (totalFiles === null || count < totalFiles) {
        const { data: response } = await (0, fileManager_1.fetchFiles)(accountId, folderId, offset, includeArchived);
        if (totalFiles === null) {
            totalFiles = response.total_count;
        }
        count += response.objects.length;
        offset += response.objects.length;
        files = files.concat(response.objects);
    }
    return files;
}
async function fetchFolderContents(accountId, folder, dest, overwrite, includeArchived) {
    try {
        await fs_extra_1.default.ensureDir(dest);
    }
    catch (err) {
        throw new FileSystemError_1.FileSystemError({ cause: err }, {
            dest,
            accountId,
            operation: 'write',
        });
    }
    const files = await fetchAllPagedFiles(accountId, folder.id, includeArchived);
    logger_1.logger.debug((0, lang_1.i18n)(`${i18nKey}.fetchingFiles`, {
        fileCount: files.length,
        folderName: folder.name || '',
    }));
    for (const file of files) {
        await downloadFile(accountId, file, dest, overwrite);
    }
    const { data: { objects: folders }, } = await (0, fileManager_1.fetchFolders)(accountId, folder.id);
    for (const folder of folders) {
        const nestedFolder = path_1.default.join(dest, folder.name);
        await fetchFolderContents(accountId, folder, nestedFolder, overwrite, includeArchived);
    }
}
// Download a folder and write to local file system.
async function downloadFolder(accountId, src, dest, folder, overwrite, includeArchived) {
    let absolutePath;
    if (folder.name) {
        absolutePath = (0, path_2.convertToLocalFileSystemPath)(path_1.default.resolve((0, path_2.getCwd)(), dest, folder.name));
    }
    else {
        absolutePath = (0, path_2.convertToLocalFileSystemPath)(path_1.default.resolve((0, path_2.getCwd)(), dest));
    }
    logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.fetchFolderStarted`, {
        src,
        path: absolutePath,
        accountId,
    }));
    await fetchFolderContents(accountId, folder, absolutePath, overwrite, includeArchived);
    logger_1.logger.success((0, lang_1.i18n)(`${i18nKey}.fetchFolderSuccess`, {
        src,
        dest,
    }));
}
// Download a single file and write to local file system.
async function downloadSingleFile(accountId, src, dest, file, overwrite, includeArchived) {
    if (!includeArchived && file.archived) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.errors.archivedFile`, { src }));
    }
    if (file.hidden) {
        throw new Error((0, lang_1.i18n)(`${i18nKey}.errors.hiddenFile`, { src }));
    }
    logger_1.logger.log((0, lang_1.i18n)(`${i18nKey}.fetchFileStarted`, {
        src,
        dest,
        accountId,
    }));
    await downloadFile(accountId, file, dest, overwrite);
    logger_1.logger.success((0, lang_1.i18n)(`${i18nKey}.fetchFileSuccess`, {
        src,
        dest,
    }));
}
// Lookup path in file manager and initiate download
async function downloadFileOrFolder(accountId, src, dest, overwrite, includeArchived) {
    try {
        if (src == '/') {
            // Filemanager API treats 'None' as the root
            const rootFolder = { id: 'None', name: '' };
            await downloadFolder(accountId, src, dest, rootFolder, overwrite, includeArchived);
        }
        else {
            const { data: { file, folder }, } = await (0, fileManager_1.fetchStat)(accountId, src);
            if (file) {
                await downloadSingleFile(accountId, src, dest, file, overwrite, includeArchived);
            }
            else if (folder) {
                await downloadFolder(accountId, src, dest, folder, overwrite, includeArchived);
            }
        }
    }
    catch (err) {
        if ((0, errors_1.isAuthError)(err)) {
            err.updateContext({
                request: src,
                accountId,
            });
        }
        throw err;
    }
}
exports.downloadFileOrFolder = downloadFileOrFolder;
